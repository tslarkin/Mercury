{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf810
{\fonttbl\f0\fnil\fcharset0 LucidaBright;\f1\fnil\fcharset0 LucidaBright-Demi;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
{\info
{\author Tim Larkin}}\margl1440\margr1440\vieww14340\viewh23720\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\fi359\pardirnatural\partightenfactor0

\f0\fs28 \cf0 The project is divided into folders. Source is the root of these folders. It also contains a few files that do not neatly fit into the other categories. Here I give an overview of the categories. Implementation etails can be found in comments in the source files.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\b\fs36 \cf0 Clocks
\f0\b0\fs28 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\fi359\pardirnatural\partightenfactor0

\i \cf0 Clocks
\i0  contains the stepper code. The most important stepper is the main clock, which drives the simulation for a single run.\
Originally Mercury didn\'92t have steppers. It merely ran a loop over all the time steps. Then we decided that it would be nice to embed a simulation in a framework which would systematically vary a parameter so that we could see the influence of those variations on some response variable. This led to a generalization that resulted in the Stepper class. \
A stepper is connected to the input of some component. It has values for the start, the end, and the increment. Steppers are nested. The innermost stepper is always a clock, so that every step the stepper defines results in the simulation running over its entire period.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\b\fs36 \cf0 Values
\f0\i\b0\fs28 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\fi359\pardirnatural\partightenfactor0
\cf0 Values
\i0  provide Mercury with a mechanism for attaching values to ports that are flexible with respect to type. This amounts to a C union type. It has a tag that identifies the current type of the variable, plus some storage for one or two dimensional arrays or strings, plus some ints that give the dimensions of the arrays.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\b\fs36 \cf0 yacc
\f0\i\b0\fs28 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\fi359\pardirnatural\partightenfactor0
\cf0 yacc
\i0  has lexer (rules.l) and parser (parse.y) files that can be compiled by yacc to produce C code that will parse strings for HTL components. The parsing of HTL functions is done in Hermes, which converts the source to a string of RPN tokens. The parser in Mercury parses only the remaining data constants, numbers, arrays, and matrices.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\b\fs36 \cf0 Tree
\f0\i\b0\fs28 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\fi359\pardirnatural\partightenfactor0
\cf0 Tree
\i0  has files that define the nodes of the model graph. The base class in HMNode, which has two main descendants, HMPort, and HMPart. A port is either an input or an output of a Hermes component. A part is the component itself.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\b\fs36 \cf0 Components
\f0\i\b0\fs28 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\fi359\pardirnatural\partightenfactor0
\cf0 Components
\i0  contains the files that define the class definitions for the various Hermes components. Each class inherits from HMPart.\
Keep in mind that the inputs and outputs are not part of the class definitions. The are defined in the XML file \'93Parts.plist\'94. When Mercury reads the Hermes file, it uses information in this file (which is shared with the Hermes project) to get certain configuration information, such as the default values for inputs.\
For a detailed description of how the HTL pseudo-machine works, start with \'93HMHTL.h\'94.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\b\fs36 \cf0 Vertex
\f0\i\b0\fs28 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\fi359\pardirnatural\partightenfactor0
\cf0 Vertex
\i0  has one file that contains methods for a dependency analysis of the model graph. Why is this necessary? Each simulation time step consists of two main phases. In the first stage, all the differential rates are computed. In the second stage, these differentials are used to update the states. The states can be update asynchronously, because states depend only on rates, never on other states; once the rates are all updated, the order in which states are updated is not significant. Rates, however, can have dependencies. Suppose a delay component\'92s delay time input comes from a lookup table, and the lookup table\'92s independent variable is a temperature which comes from a data file. Then the lookup table has to be updated before the delay asks for the delay time, and the output temperature of the data file has to be updated before it\'92s used by the lookup table. This situation produces a dependency graph. Before the model can begin, all these dependency graphs have to be calculated by the methods in \'93Dependency.m\'94.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\b\fs36 \cf0 Other files
\f0\i\b0\fs28 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\fi359\pardirnatural\partightenfactor0

\i0 \cf0 \'93Hernix_Prefix.pch\'94 is the project\'92s precompiled header. This is automatically generated by the project.\
\'93Hernix.m\'94 contains 
\i main
\i0 . It creates an instance of AppController, and sends it a message to run the simulation.\
\'93Instantiator.m\'94 contains the code that reads the Hermes XML file and instantiates the model objects. It also contains, perhaps somewhat arbitrarily, the code for wiring together the hexagons of a spatial model.\
\'93Hexmap.m\'94 contains code for dealing with hexagonal tiles.\
\'93AppController.m\'94 contains the code for the application controller, which does the work of initializing the model based on the Hermes document, configuring the simulation based on the Crocus document, starting the simulation, and cleaning up after the simulation is complete.\
\'93XML_procedures.m\'94 exists in two versions, one for macOS and one for Linux. They both do the same jobs, but use different XML libraries. The main task is to set up the simulation parameters by reading the Crocus file. The procedures here are called by the AppController.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\b\fs36 \cf0 Sample files
\f0\i\b0\fs28 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\fi359\pardirnatural\partightenfactor0

\i0 \cf0 \'93Sample.xml\'94 is a simple Hermes model.\
\'93Setup.xml\'94 is a sample Crocus document.\
\'93sample_output.txt\'94 is a sample Mercury output file.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\b\fs36 \cf0 Documentation
\f0\i\b0\fs28 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\fi359\pardirnatural\partightenfactor0

\i0 \cf0 This folder contains make files for GnuStep, the Linux port of NextStep.\
}