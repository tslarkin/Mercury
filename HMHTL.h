//
//  HMHTL.h
//  Hernix
//
//  Created by Timothy Larkin on 7/26/08.
//  Copyright 2008 Abstract Tools. All rights reserved.
//

/*
 The design of this pseudo-machine was taken from a book <reference needed>.
*/

/*
 An HTL procedure looks like this:
 
     if (th < 0.000001) then
        damrate:= 0.0;
     else
        damrate:=cd/th;
     endif;
 
 The HTL compiler in Hermes turns this into a string of tokens and data in Reverse Polish Notation:
 
 th 0.000001 makeFloat lt if 0.0 makeFloat damrate assign else cd th divide damrate assign endif
 
 An HTL in Mercury runs a pseudo-machine that executes the RPN program. It has an
 evaluation stack, and a memory pool. The memory pool is shared between all the
 HMHTL components in the model. 
 
 !!<This probably ought to change now that we have
 spatial simulations. A 100x100 space has 10,000 copies of the model, which may
 have dozens of HMHTL instances. The current size of the memory pool is 10,000,
 which is obviously inadequate for a spatial simulation. Instead of increasing
 the size of the memory pool by a couple of orders of magnitude, it would be better
 to refactor the code so that each instance has its own memory pool, just as each
 instance has its own stack.>
 
 !!<In addition, the use of a global memory pool and a global pointer to the next
 available entry in the pool has not properly taken into account the possibility
 of multiple threads colliding during allocation, causing chaos.>
 
 Those considerations aside, I will describe the operation of the pseudo-machine.
 
 1) When the HMHTL class is created, its initialize method is automatically called.
    This creates the memory store, and initializes the symbol table, making entries
    for "dt", "time", and "julianday".
 2) Because a simulation can be run more than once during a single run of Mercury,
    there are two initialization routines for an instance of HMHTL. The first,
    awake, is called once; it converts the list of tokens in RPN form to opcodes
    that can be executed on the pseudo-machine. The second, initialize, is called
    before each simulation run to reset the machine state.
 3) The machine is run during updateRates. This iterates over the opcodes, interpreting
    each opcode in a large case statement.
 
 If you want to understand how the machine works, first take a look at the awake method,
 which shows how the RPN tokens generated by Hermes are converted into machine instructions.
 Then study updateRates, which shows how instructions are executed to produce results.
 
 */


#import <Foundation/Foundation.h>
#import "HMPart.h"
#import "Value.h"

@class HMPort;

// These are the opcodes executed by the case statement in updateRates.
typedef enum {
	kPushValue, kApply1, kApply2, kJump, kIf, kPushFunc, kSum, kAssign, kRSum, kCSum
} opcodeType;

// An instruction is an opcode plus possibly null data.
typedef struct {
	opcodeType opcode;
	unsigned long data;
} instruction, *instructionPtr;

// A symbol table entry has a name (symbol) and a value of type Value.
typedef struct {
	char *symbol;
	Value *value;
} symbolTableEntry, *symbolTableEntryPtr;

@interface HMHTL : HMPart {
    // The RPN version of the program as a string.
    NSString *programrpn;
    // The input and output names. Eg:
    // <attribute name="identifiers" type="string">damrate,th,cd</attribute>
    NSString *identifiers;
    // The symbol table.
    symbolTableEntry *ste;
    // The length of the symbol table.
    int steLength;
    // The instructions, an array of pointers to instructions.
    instruction **instructions;
    // The number of instructions.
    int instructionCount;
    // The set of local (static) variables, that get values that persist
    // across time steps.
    NSMutableArray *localVariables;
    // The evaluation stack.
    void *stack[32];
    // Pointer to the top of the stack.
    unsigned char tos;
}

+(void)addSharedVariable:(NSString*)token withValue:(Value*)value;
+(symbolTableEntryPtr)sharedVariableWithName:(NSString*)name;
+(Value*)finalValueForPort:(HMPort*)port;
@end
